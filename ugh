






























  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api], with the caveat that the SpiderMonkey-specific syntax
  // (`let`, `yield`, inline XML, etc) is not recognized.
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

  options_t options = {};  auto input = std::string("");  auto inputLen = 0;  std::string sourceFile = std::string(""); 

  auto parse (auto inpt, auto opts) {
    input = String(inpt); inputLen = input.length();
    setOptions(opts);
    initTokenState();
    return parseTopLevel(options.program);
  };

  // A second optional argument can be given to further configure
  // the parser process. These options are recognized:

  options_t defaultOptions  = {ecmaVersion: 5, strictSemicolons: false, allowTrailingCommas: true, forbidReserved: false, allowReturnOutsideFunction: false, locations: false, onComment: null, ranges: false, program: null, sourceFile: "", directSourceFile: ""}; 

  // Acorn is organized as a tokenizer and a recursive-descent parser.
  // The `tokenize` export provides an interface to the tokenizer.
  // Because the tokenizer is optimized for being efficiently used by
  // the Acorn parser itself, this interface is somewhat crude and not
  // very modular. Performing another parse or call to `tokenize` will
  // reset the internal state, and invalidate existing tokenizers.
































  // State is kept in (closure-)global variables. We already saw the
  // `options`, `input`, and `inputLen` variables above.

  // The current position of the tokenizer in the input.

  auto tokPos = 0; 

  // The start and end offsets of the current token.

  int tokStart = 0;  auto tokEnd = 0; 

  // When `options.locations` is true, these hold objects
  // containing the tokens start and end line/column pairs.

  int tokStartLoc = 0;  auto tokEndLoc = 0; 

  // The type and value of the current token. Token types are objects,
  // named by variables against which they can be compared, and
  // holding properties that describe them (indicating, for example,
  // the precedence of an infix opr, and the original name of a
  // keyword token). The kind of value that's held in `tokVal` depends
  // on the type of the token. For literals, it is the literal value,
  // for operators, the opr name, and so on.

  keyword_t tokType = {};  auto tokVal = 0; 

  // Interal state for the tokenizer. To distinguish between division
  // operators and regular expressions, it remembers whether the last
  // token was one that is allowed to be followed by an expression.
  // (If it is, a slash is probably a regexp, if it isn't it's a
  // division opr. See the `parseStatement` function for a
  // caveat.)

  auto tokRegexpAllowed = 0; 

  // When `options.locations` is true, these are used to keep
  // track of the current line, and know when a new line has been
  // entered.

  auto tokCurLine = 0;  auto tokLineStart = 0; 

  // These store the position of the previous token, which is useful
  // when finishing a node and assigning its `end` position.

  auto lastStart = 0;  auto lastEnd = 0;  auto lastEndLoc = 0; 

  // This is the parser's state. `inFunction` is used to reject
  // `return` statements outside of functions, `labels` to verify that
  // `break` and `continue` have somewhere to jump to, and `strict`
  // indicates whether strict mode is on.

  auto inFunction = 0;  auto labels = std::vector<label_t>();  auto strict = 0; 

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.









  // Reused empty array added for node fields that are always empty.

  auto empty = std::vector<Node*>(); 

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // These are the general types. The `type` property is only used to
  // make them recognizeable when debugging.

  struct keyword_t _num = {_id: 1, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "num"};  struct keyword_t _regexp = {_id: 2, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "regexp"};  struct keyword_t _string = {_id: 3, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "string"}; 
  struct keyword_t _name = {_id: 4, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "name"};  struct keyword_t _eof = {_id: 5, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "eof"}; 

  // Keyword tokens. The `keyword` property (also used in keyword-like
  // operators) indicates that the token originated from an
  // identifier-like word, which is used when parsing property names.
  //
  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  struct keyword_t _break = {_id: 6, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "break", postfix: false, prefix: false, type: ""};  struct keyword_t _case = {_id: 7, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "case", postfix: false, prefix: false, type: ""};  struct keyword_t _catch = {_id: 8, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "catch", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _continue = {_id: 9, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "continue", postfix: false, prefix: false, type: ""};  struct keyword_t _debugger = {_id: 10, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "debugger", postfix: false, prefix: false, type: ""};  struct keyword_t _default = {_id: 11, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "default", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _do = {_id: 12, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: true, isUpdate: false, keyword: "do", postfix: false, prefix: false, type: ""};  struct keyword_t _else = {_id: 13, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "else", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _finally = {_id: 14, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "finally", postfix: false, prefix: false, type: ""};  struct keyword_t _for = {_id: 15, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: true, isUpdate: false, keyword: "for", postfix: false, prefix: false, type: ""};  struct keyword_t _function = {_id: 16, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "function", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _if = {_id: 17, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "if", postfix: false, prefix: false, type: ""};  struct keyword_t _return = {_id: 18, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "return", postfix: false, prefix: false, type: ""};  struct keyword_t _switch = {_id: 19, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "switch", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _throw = {_id: 20, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "throw", postfix: false, prefix: false, type: ""};  struct keyword_t _try = {_id: 21, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "try", postfix: false, prefix: false, type: ""};  struct keyword_t _var = {_id: 22, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "var", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _let = {_id: 23, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "let", postfix: false, prefix: false, type: ""};  struct keyword_t _const = {_id: 24, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "const", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _while = {_id: 25, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: true, isUpdate: false, keyword: "while", postfix: false, prefix: false, type: ""};  struct keyword_t _with = {_id: 26, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "with", postfix: false, prefix: false, type: ""};  struct keyword_t _new = {_id: 27, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "new", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _this = {_id: 28, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "this", postfix: false, prefix: false, type: ""}; 

  // The keywords that denote values.

  struct keyword_t _null = {_id: 29, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "null", postfix: false, prefix: false, type: ""};  struct keyword_t _true = {_id: 30, atomValue: ATOM_TRUE, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "true", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _false = {_id: 31, atomValue: ATOM_FALSE, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "false", postfix: false, prefix: false, type: ""}; 

  // Some keywords are treated as regular operators. `in` sometimes
  // (when parsing `for`) needs to be tested against specifically, so
  // we assign a variable name to it for quick comparing.

  struct keyword_t _in = {_id: 32, atomValue: ATOM_NULL, beforeExpr: true, binop: 7, isAssign: false, isLoop: false, isUpdate: false, keyword: "in", postfix: false, prefix: false, type: ""}; 















  // Punctuation token types. Again, the `type` property is purely for debugging.

  struct keyword_t _bracketL = {_id: 33, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "["};  struct keyword_t _bracketR = {_id: 34, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "]"};  struct keyword_t _braceL = {_id: 35, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "{"}; 
  struct keyword_t _braceR = {_id: 36, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "}"};  struct keyword_t _parenL = {_id: 37, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "("};  struct keyword_t _parenR = {_id: 38, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ")"}; 
  struct keyword_t _comma = {_id: 39, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ","};  struct keyword_t _semi = {_id: 40, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ";"}; 
  struct keyword_t _colon = {_id: 41, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ":"};  struct keyword_t _dot = {_id: 42, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "."};  struct keyword_t _ellipsis = {_id: 43, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "..."};  struct keyword_t _question = {_id: 44, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: "?"}; 

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this opr is a binary
  // opr, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the opr as a prefix or postfix
  // unary opr. `isUpdate` specifies that the node produced by
  // the opr should be of type UpdateExpression rather than
  // simply UnaryExpression (`++` and `--`).
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  struct keyword_t _slash = {_id: 45, atomValue: ATOM_NULL, beforeExpr: true, binop: 10, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""};  struct keyword_t _eq = {_id: 46, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: true, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _assign = {_id: 47, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: true, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _incDec = {_id: 48, atomValue: ATOM_NULL, beforeExpr: false, binop: -1, isAssign: false, isLoop: false, isUpdate: true, keyword: "", postfix: true, prefix: true, type: ""};  struct keyword_t _prefix = {_id: 49, atomValue: ATOM_NULL, beforeExpr: true, binop: -1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: true, type: ""}; 
  struct keyword_t _logicalOR = {_id: 50, atomValue: ATOM_NULL, beforeExpr: true, binop: 1, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _logicalAND = {_id: 51, atomValue: ATOM_NULL, beforeExpr: true, binop: 2, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _bitwiseOR = {_id: 52, atomValue: ATOM_NULL, beforeExpr: true, binop: 3, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _bitwiseXOR = {_id: 53, atomValue: ATOM_NULL, beforeExpr: true, binop: 4, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _bitwiseAND = {_id: 54, atomValue: ATOM_NULL, beforeExpr: true, binop: 5, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _equality = {_id: 55, atomValue: ATOM_NULL, beforeExpr: true, binop: 6, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _relational = {_id: 56, atomValue: ATOM_NULL, beforeExpr: true, binop: 7, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _bitShift = {_id: 57, atomValue: ATOM_NULL, beforeExpr: true, binop: 8, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""}; 
  struct keyword_t _plusMin = {_id: 58, atomValue: ATOM_NULL, beforeExpr: true, binop: 9, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: true, type: ""}; 
  struct keyword_t _multiplyModulo = {_id: 59, atomValue: ATOM_NULL, beforeExpr: true, binop: 10, isAssign: false, isLoop: false, isUpdate: false, keyword: "", postfix: false, prefix: false, type: ""}; 










  // This is a trick taken from Esprima. It turns out that, on
  // non-Chrome browsers, to check whether a string is in a set, a
  // predicate containing a big ugly `switch` statement is faster than
  // a regular expression, and on Chrome the two are about on par.
  // This function uses `eval` (non-lexical) to produce such a
  // predicate from a space-separated string of words.










































  // The ECMAScript 3 reserved word list.

  bool isReservedWord3(std::string arg) { return false; } 

  // ECMAScript 5 reserved words.

  bool isReservedWord5(std::string arg) { return false; } 

  // The additional reserved words in strict mode.

  bool isStrictReservedWord(std::string arg) { return false; } 

  // The forbidden variable names in strict mode.

  bool isStrictBadIdWord(std::string arg) { return false; } 

  // And the keywords.

  auto ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"; 

  bool isEcma5AndLessKeyword(std::string arg) { return false; } 

  bool isEcma6Keyword(std::string arg) { return false; } 

  auto isKeyword = isEcma5AndLessKeyword; 

  // ## Character categories

  // Big ugly regular expressions that match characters in the
  // whitespace, identifier, and identifier-start categories. These
  // are only applied when a character is found to actually have a
  // code point above 128.
  // Generated by `tools/generate-identifier-regex.js`.

/*C bool nonASCIIwhitespace (std::string arg) { for (size_t i=0;i<arg.length();i++) { switch (arg[i]) {  case 0x1680: case 0x180e: case 0x2000 ... 0x200a: case 0x202f: case 0x205f: case 0x3000: case 0xfeff: break; default: return false; } } return true; };*/


/*C bool nonASCIIidentifierStart (std::string arg) { for (size_t i=0;i<arg.length();i++) { switch (arg[i]) {  case 0xaa: case 0xb5: case 0xba: case 0xc0 ... 0xd6: case 0xd8 ... 0xf6: case 0xf8 ... 0x2c1: case 0x2c6 ... 0x2d1: case 0x2e0 ... 0x2e4: case 0x2ec: case 0x2ee: case 0x370 ... 0x374: case 0x376: case 0x377: case 0x37a ... 0x37d: case 0x37f: case 0x386: case 0x388 ... 0x38a: case 0x38c: case 0x38e ... 0x3a1: case 0x3a3 ... 0x3f5: case 0x3f7 ... 0x481: case 0x48a ... 0x52f: case 0x531 ... 0x556: case 0x559: case 0x561 ... 0x587: case 0x5d0 ... 0x5ea: case 0x5f0 ... 0x5f2: case 0x620 ... 0x64a: case 0x66e: case 0x66f: case 0x671 ... 0x6d3: case 0x6d5: case 0x6e5: case 0x6e6: case 0x6ee: case 0x6ef: case 0x6fa ... 0x6fc: case 0x6ff: case 0x710: case 0x712 ... 0x72f: case 0x74d ... 0x7a5: case 0x7b1: case 0x7ca ... 0x7ea: case 0x7f4: case 0x7f5: case 0x7fa: case 0x800 ... 0x815: case 0x81a: case 0x824: case 0x828: case 0x840 ... 0x858: case 0x8a0 ... 0x8b2: case 0x904 ... 0x939: case 0x93d: case 0x950: case 0x958 ... 0x961: case 0x971 ... 0x980: case 0x985 ... 0x98c: case 0x98f: case 0x990: case 0x993 ... 0x9a8: case 0x9aa ... 0x9b0: case 0x9b2: case 0x9b6 ... 0x9b9: case 0x9bd: case 0x9ce: case 0x9dc: case 0x9dd: case 0x9df ... 0x9e1: case 0x9f0: case 0x9f1: case 0xa05 ... 0xa0a: case 0xa0f: case 0xa10: case 0xa13 ... 0xa28: case 0xa2a ... 0xa30: case 0xa32: case 0xa33: case 0xa35: case 0xa36: case 0xa38: case 0xa39: case 0xa59 ... 0xa5c: case 0xa5e: case 0xa72 ... 0xa74: case 0xa85 ... 0xa8d: case 0xa8f ... 0xa91: case 0xa93 ... 0xaa8: case 0xaaa ... 0xab0: case 0xab2: case 0xab3: case 0xab5 ... 0xab9: case 0xabd: case 0xad0: case 0xae0: case 0xae1: case 0xb05 ... 0xb0c: case 0xb0f: case 0xb10: case 0xb13 ... 0xb28: case 0xb2a ... 0xb30: case 0xb32: case 0xb33: case 0xb35 ... 0xb39: case 0xb3d: case 0xb5c: case 0xb5d: case 0xb5f ... 0xb61: case 0xb71: case 0xb83: case 0xb85 ... 0xb8a: case 0xb8e ... 0xb90: case 0xb92 ... 0xb95: case 0xb99: case 0xb9a: case 0xb9c: case 0xb9e: case 0xb9f: case 0xba3: case 0xba4: case 0xba8 ... 0xbaa: case 0xbae ... 0xbb9: case 0xbd0: case 0xc05 ... 0xc0c: case 0xc0e ... 0xc10: case 0xc12 ... 0xc28: case 0xc2a ... 0xc39: case 0xc3d: case 0xc58: case 0xc59: case 0xc60: case 0xc61: case 0xc85 ... 0xc8c: case 0xc8e ... 0xc90: case 0xc92 ... 0xca8: case 0xcaa ... 0xcb3: case 0xcb5 ... 0xcb9: case 0xcbd: case 0xcde: case 0xce0: case 0xce1: case 0xcf1: case 0xcf2: case 0xd05 ... 0xd0c: case 0xd0e ... 0xd10: case 0xd12 ... 0xd3a: case 0xd3d: case 0xd4e: case 0xd60: case 0xd61: case 0xd7a ... 0xd7f: case 0xd85 ... 0xd96: case 0xd9a ... 0xdb1: case 0xdb3 ... 0xdbb: case 0xdbd: case 0xdc0 ... 0xdc6: case 0xe01 ... 0xe30: case 0xe32: case 0xe33: case 0xe40 ... 0xe46: case 0xe81: case 0xe82: case 0xe84: case 0xe87: case 0xe88: case 0xe8a: case 0xe8d: case 0xe94 ... 0xe97: case 0xe99 ... 0xe9f: case 0xea1 ... 0xea3: case 0xea5: case 0xea7: case 0xeaa: case 0xeab: case 0xead ... 0xeb0: case 0xeb2: case 0xeb3: case 0xebd: case 0xec0 ... 0xec4: case 0xec6: case 0xedc ... 0xedf: case 0xf00: case 0xf40 ... 0xf47: case 0xf49 ... 0xf6c: case 0xf88 ... 0xf8c: case 0x1000 ... 0x102a: case 0x103f: case 0x1050 ... 0x1055: case 0x105a ... 0x105d: case 0x1061: case 0x1065: case 0x1066: case 0x106e ... 0x1070: case 0x1075 ... 0x1081: case 0x108e: case 0x10a0 ... 0x10c5: case 0x10c7: case 0x10cd: case 0x10d0 ... 0x10fa: case 0x10fc ... 0x1248: case 0x124a ... 0x124d: case 0x1250 ... 0x1256: case 0x1258: case 0x125a ... 0x125d: case 0x1260 ... 0x1288: case 0x128a ... 0x128d: case 0x1290 ... 0x12b0: case 0x12b2 ... 0x12b5: case 0x12b8 ... 0x12be: case 0x12c0: case 0x12c2 ... 0x12c5: case 0x12c8 ... 0x12d6: case 0x12d8 ... 0x1310: case 0x1312 ... 0x1315: case 0x1318 ... 0x135a: case 0x1380 ... 0x138f: case 0x13a0 ... 0x13f4: case 0x1401 ... 0x166c: case 0x166f ... 0x167f: case 0x1681 ... 0x169a: case 0x16a0 ... 0x16ea: case 0x16ee ... 0x16f8: case 0x1700 ... 0x170c: case 0x170e ... 0x1711: case 0x1720 ... 0x1731: case 0x1740 ... 0x1751: case 0x1760 ... 0x176c: case 0x176e ... 0x1770: case 0x1780 ... 0x17b3: case 0x17d7: case 0x17dc: case 0x1820 ... 0x1877: case 0x1880 ... 0x18a8: case 0x18aa: case 0x18b0 ... 0x18f5: case 0x1900 ... 0x191e: case 0x1950 ... 0x196d: case 0x1970 ... 0x1974: case 0x1980 ... 0x19ab: case 0x19c1 ... 0x19c7: case 0x1a00 ... 0x1a16: case 0x1a20 ... 0x1a54: case 0x1aa7: case 0x1b05 ... 0x1b33: case 0x1b45 ... 0x1b4b: case 0x1b83 ... 0x1ba0: case 0x1bae: case 0x1baf: case 0x1bba ... 0x1be5: case 0x1c00 ... 0x1c23: case 0x1c4d ... 0x1c4f: case 0x1c5a ... 0x1c7d: case 0x1ce9 ... 0x1cec: case 0x1cee ... 0x1cf1: case 0x1cf5: case 0x1cf6: case 0x1d00 ... 0x1dbf: case 0x1e00 ... 0x1f15: case 0x1f18 ... 0x1f1d: case 0x1f20 ... 0x1f45: case 0x1f48 ... 0x1f4d: case 0x1f50 ... 0x1f57: case 0x1f59: case 0x1f5b: case 0x1f5d: case 0x1f5f ... 0x1f7d: case 0x1f80 ... 0x1fb4: case 0x1fb6 ... 0x1fbc: case 0x1fbe: case 0x1fc2 ... 0x1fc4: case 0x1fc6 ... 0x1fcc: case 0x1fd0 ... 0x1fd3: case 0x1fd6 ... 0x1fdb: case 0x1fe0 ... 0x1fec: case 0x1ff2 ... 0x1ff4: case 0x1ff6 ... 0x1ffc: case 0x2071: case 0x207f: case 0x2090 ... 0x209c: case 0x2102: case 0x2107: case 0x210a ... 0x2113: case 0x2115: case 0x2119 ... 0x211d: case 0x2124: case 0x2126: case 0x2128: case 0x212a ... 0x212d: case 0x212f ... 0x2139: case 0x213c ... 0x213f: case 0x2145 ... 0x2149: case 0x214e: case 0x2160 ... 0x2188: case 0x2c00 ... 0x2c2e: case 0x2c30 ... 0x2c5e: case 0x2c60 ... 0x2ce4: case 0x2ceb ... 0x2cee: case 0x2cf2: case 0x2cf3: case 0x2d00 ... 0x2d25: case 0x2d27: case 0x2d2d: case 0x2d30 ... 0x2d67: case 0x2d6f: case 0x2d80 ... 0x2d96: case 0x2da0 ... 0x2da6: case 0x2da8 ... 0x2dae: case 0x2db0 ... 0x2db6: case 0x2db8 ... 0x2dbe: case 0x2dc0 ... 0x2dc6: case 0x2dc8 ... 0x2dce: case 0x2dd0 ... 0x2dd6: case 0x2dd8 ... 0x2dde: case 0x2e2f: case 0x3005 ... 0x3007: case 0x3021 ... 0x3029: case 0x3031 ... 0x3035: case 0x3038 ... 0x303c: case 0x3041 ... 0x3096: case 0x309d ... 0x309f: case 0x30a1 ... 0x30fa: case 0x30fc ... 0x30ff: case 0x3105 ... 0x312d: case 0x3131 ... 0x318e: case 0x31a0 ... 0x31ba: case 0x31f0 ... 0x31ff: case 0x3400 ... 0x4db5: case 0x4e00 ... 0x9fcc: case 0xa000 ... 0xa48c: case 0xa4d0 ... 0xa4fd: case 0xa500 ... 0xa60c: case 0xa610 ... 0xa61f: case 0xa62a: case 0xa62b: case 0xa640 ... 0xa66e: case 0xa67f ... 0xa69d: case 0xa6a0 ... 0xa6ef: case 0xa717 ... 0xa71f: case 0xa722 ... 0xa788: case 0xa78b ... 0xa78e: case 0xa790 ... 0xa7ad: case 0xa7b0: case 0xa7b1: case 0xa7f7 ... 0xa801: case 0xa803 ... 0xa805: case 0xa807 ... 0xa80a: case 0xa80c ... 0xa822: case 0xa840 ... 0xa873: case 0xa882 ... 0xa8b3: case 0xa8f2 ... 0xa8f7: case 0xa8fb: case 0xa90a ... 0xa925: case 0xa930 ... 0xa946: case 0xa960 ... 0xa97c: case 0xa984 ... 0xa9b2: case 0xa9cf: case 0xa9e0 ... 0xa9e4: case 0xa9e6 ... 0xa9ef: case 0xa9fa ... 0xa9fe: case 0xaa00 ... 0xaa28: case 0xaa40 ... 0xaa42: case 0xaa44 ... 0xaa4b: case 0xaa60 ... 0xaa76: case 0xaa7a: case 0xaa7e ... 0xaaaf: case 0xaab1: case 0xaab5: case 0xaab6: case 0xaab9 ... 0xaabd: case 0xaac0: case 0xaac2: case 0xaadb ... 0xaadd: case 0xaae0 ... 0xaaea: case 0xaaf2 ... 0xaaf4: case 0xab01 ... 0xab06: case 0xab09 ... 0xab0e: case 0xab11 ... 0xab16: case 0xab20 ... 0xab26: case 0xab28 ... 0xab2e: case 0xab30 ... 0xab5a: case 0xab5c ... 0xab5f: case 0xab64: case 0xab65: case 0xabc0 ... 0xabe2: case 0xac00 ... 0xd7a3: case 0xd7b0 ... 0xd7c6: case 0xd7cb ... 0xd7fb: case 0xf900 ... 0xfa6d: case 0xfa70 ... 0xfad9: case 0xfb00 ... 0xfb06: case 0xfb13 ... 0xfb17: case 0xfb1d: case 0xfb1f ... 0xfb28: case 0xfb2a ... 0xfb36: case 0xfb38 ... 0xfb3c: case 0xfb3e: case 0xfb40: case 0xfb41: case 0xfb43: case 0xfb44: case 0xfb46 ... 0xfbb1: case 0xfbd3 ... 0xfd3d: case 0xfd50 ... 0xfd8f: case 0xfd92 ... 0xfdc7: case 0xfdf0 ... 0xfdfb: case 0xfe70 ... 0xfe74: case 0xfe76 ... 0xfefc: case 0xff21 ... 0xff3a: case 0xff41 ... 0xff5a: case 0xff66 ... 0xffbe: case 0xffc2 ... 0xffc7: case 0xffca ... 0xffcf: case 0xffd2 ... 0xffd7: case 0xffda ... 0xffdc: break; default: return false; } } return true; };*/
/*C bool nonASCIIidentifier (std::string arg) { for (size_t i=0;i<arg.length();i++) { switch (arg[i]) {  case 0xaa: case 0xb5: case 0xba: case 0xc0 ... 0xd6: case 0xd8 ... 0xf6: case 0xf8 ... 0x2c1: case 0x2c6 ... 0x2d1: case 0x2e0 ... 0x2e4: case 0x2ec: case 0x2ee: case 0x370 ... 0x374: case 0x376: case 0x377: case 0x37a ... 0x37d: case 0x37f: case 0x386: case 0x388 ... 0x38a: case 0x38c: case 0x38e ... 0x3a1: case 0x3a3 ... 0x3f5: case 0x3f7 ... 0x481: case 0x48a ... 0x52f: case 0x531 ... 0x556: case 0x559: case 0x561 ... 0x587: case 0x5d0 ... 0x5ea: case 0x5f0 ... 0x5f2: case 0x620 ... 0x64a: case 0x66e: case 0x66f: case 0x671 ... 0x6d3: case 0x6d5: case 0x6e5: case 0x6e6: case 0x6ee: case 0x6ef: case 0x6fa ... 0x6fc: case 0x6ff: case 0x710: case 0x712 ... 0x72f: case 0x74d ... 0x7a5: case 0x7b1: case 0x7ca ... 0x7ea: case 0x7f4: case 0x7f5: case 0x7fa: case 0x800 ... 0x815: case 0x81a: case 0x824: case 0x828: case 0x840 ... 0x858: case 0x8a0 ... 0x8b2: case 0x904 ... 0x939: case 0x93d: case 0x950: case 0x958 ... 0x961: case 0x971 ... 0x980: case 0x985 ... 0x98c: case 0x98f: case 0x990: case 0x993 ... 0x9a8: case 0x9aa ... 0x9b0: case 0x9b2: case 0x9b6 ... 0x9b9: case 0x9bd: case 0x9ce: case 0x9dc: case 0x9dd: case 0x9df ... 0x9e1: case 0x9f0: case 0x9f1: case 0xa05 ... 0xa0a: case 0xa0f: case 0xa10: case 0xa13 ... 0xa28: case 0xa2a ... 0xa30: case 0xa32: case 0xa33: case 0xa35: case 0xa36: case 0xa38: case 0xa39: case 0xa59 ... 0xa5c: case 0xa5e: case 0xa72 ... 0xa74: case 0xa85 ... 0xa8d: case 0xa8f ... 0xa91: case 0xa93 ... 0xaa8: case 0xaaa ... 0xab0: case 0xab2: case 0xab3: case 0xab5 ... 0xab9: case 0xabd: case 0xad0: case 0xae0: case 0xae1: case 0xb05 ... 0xb0c: case 0xb0f: case 0xb10: case 0xb13 ... 0xb28: case 0xb2a ... 0xb30: case 0xb32: case 0xb33: case 0xb35 ... 0xb39: case 0xb3d: case 0xb5c: case 0xb5d: case 0xb5f ... 0xb61: case 0xb71: case 0xb83: case 0xb85 ... 0xb8a: case 0xb8e ... 0xb90: case 0xb92 ... 0xb95: case 0xb99: case 0xb9a: case 0xb9c: case 0xb9e: case 0xb9f: case 0xba3: case 0xba4: case 0xba8 ... 0xbaa: case 0xbae ... 0xbb9: case 0xbd0: case 0xc05 ... 0xc0c: case 0xc0e ... 0xc10: case 0xc12 ... 0xc28: case 0xc2a ... 0xc39: case 0xc3d: case 0xc58: case 0xc59: case 0xc60: case 0xc61: case 0xc85 ... 0xc8c: case 0xc8e ... 0xc90: case 0xc92 ... 0xca8: case 0xcaa ... 0xcb3: case 0xcb5 ... 0xcb9: case 0xcbd: case 0xcde: case 0xce0: case 0xce1: case 0xcf1: case 0xcf2: case 0xd05 ... 0xd0c: case 0xd0e ... 0xd10: case 0xd12 ... 0xd3a: case 0xd3d: case 0xd4e: case 0xd60: case 0xd61: case 0xd7a ... 0xd7f: case 0xd85 ... 0xd96: case 0xd9a ... 0xdb1: case 0xdb3 ... 0xdbb: case 0xdbd: case 0xdc0 ... 0xdc6: case 0xe01 ... 0xe30: case 0xe32: case 0xe33: case 0xe40 ... 0xe46: case 0xe81: case 0xe82: case 0xe84: case 0xe87: case 0xe88: case 0xe8a: case 0xe8d: case 0xe94 ... 0xe97: case 0xe99 ... 0xe9f: case 0xea1 ... 0xea3: case 0xea5: case 0xea7: case 0xeaa: case 0xeab: case 0xead ... 0xeb0: case 0xeb2: case 0xeb3: case 0xebd: case 0xec0 ... 0xec4: case 0xec6: case 0xedc ... 0xedf: case 0xf00: case 0xf40 ... 0xf47: case 0xf49 ... 0xf6c: case 0xf88 ... 0xf8c: case 0x1000 ... 0x102a: case 0x103f: case 0x1050 ... 0x1055: case 0x105a ... 0x105d: case 0x1061: case 0x1065: case 0x1066: case 0x106e ... 0x1070: case 0x1075 ... 0x1081: case 0x108e: case 0x10a0 ... 0x10c5: case 0x10c7: case 0x10cd: case 0x10d0 ... 0x10fa: case 0x10fc ... 0x1248: case 0x124a ... 0x124d: case 0x1250 ... 0x1256: case 0x1258: case 0x125a ... 0x125d: case 0x1260 ... 0x1288: case 0x128a ... 0x128d: case 0x1290 ... 0x12b0: case 0x12b2 ... 0x12b5: case 0x12b8 ... 0x12be: case 0x12c0: case 0x12c2 ... 0x12c5: case 0x12c8 ... 0x12d6: case 0x12d8 ... 0x1310: case 0x1312 ... 0x1315: case 0x1318 ... 0x135a: case 0x1380 ... 0x138f: case 0x13a0 ... 0x13f4: case 0x1401 ... 0x166c: case 0x166f ... 0x167f: case 0x1681 ... 0x169a: case 0x16a0 ... 0x16ea: case 0x16ee ... 0x16f8: case 0x1700 ... 0x170c: case 0x170e ... 0x1711: case 0x1720 ... 0x1731: case 0x1740 ... 0x1751: case 0x1760 ... 0x176c: case 0x176e ... 0x1770: case 0x1780 ... 0x17b3: case 0x17d7: case 0x17dc: case 0x1820 ... 0x1877: case 0x1880 ... 0x18a8: case 0x18aa: case 0x18b0 ... 0x18f5: case 0x1900 ... 0x191e: case 0x1950 ... 0x196d: case 0x1970 ... 0x1974: case 0x1980 ... 0x19ab: case 0x19c1 ... 0x19c7: case 0x1a00 ... 0x1a16: case 0x1a20 ... 0x1a54: case 0x1aa7: case 0x1b05 ... 0x1b33: case 0x1b45 ... 0x1b4b: case 0x1b83 ... 0x1ba0: case 0x1bae: case 0x1baf: case 0x1bba ... 0x1be5: case 0x1c00 ... 0x1c23: case 0x1c4d ... 0x1c4f: case 0x1c5a ... 0x1c7d: case 0x1ce9 ... 0x1cec: case 0x1cee ... 0x1cf1: case 0x1cf5: case 0x1cf6: case 0x1d00 ... 0x1dbf: case 0x1e00 ... 0x1f15: case 0x1f18 ... 0x1f1d: case 0x1f20 ... 0x1f45: case 0x1f48 ... 0x1f4d: case 0x1f50 ... 0x1f57: case 0x1f59: case 0x1f5b: case 0x1f5d: case 0x1f5f ... 0x1f7d: case 0x1f80 ... 0x1fb4: case 0x1fb6 ... 0x1fbc: case 0x1fbe: case 0x1fc2 ... 0x1fc4: case 0x1fc6 ... 0x1fcc: case 0x1fd0 ... 0x1fd3: case 0x1fd6 ... 0x1fdb: case 0x1fe0 ... 0x1fec: case 0x1ff2 ... 0x1ff4: case 0x1ff6 ... 0x1ffc: case 0x2071: case 0x207f: case 0x2090 ... 0x209c: case 0x2102: case 0x2107: case 0x210a ... 0x2113: case 0x2115: case 0x2119 ... 0x211d: case 0x2124: case 0x2126: case 0x2128: case 0x212a ... 0x212d: case 0x212f ... 0x2139: case 0x213c ... 0x213f: case 0x2145 ... 0x2149: case 0x214e: case 0x2160 ... 0x2188: case 0x2c00 ... 0x2c2e: case 0x2c30 ... 0x2c5e: case 0x2c60 ... 0x2ce4: case 0x2ceb ... 0x2cee: case 0x2cf2: case 0x2cf3: case 0x2d00 ... 0x2d25: case 0x2d27: case 0x2d2d: case 0x2d30 ... 0x2d67: case 0x2d6f: case 0x2d80 ... 0x2d96: case 0x2da0 ... 0x2da6: case 0x2da8 ... 0x2dae: case 0x2db0 ... 0x2db6: case 0x2db8 ... 0x2dbe: case 0x2dc0 ... 0x2dc6: case 0x2dc8 ... 0x2dce: case 0x2dd0 ... 0x2dd6: case 0x2dd8 ... 0x2dde: case 0x2e2f: case 0x3005 ... 0x3007: case 0x3021 ... 0x3029: case 0x3031 ... 0x3035: case 0x3038 ... 0x303c: case 0x3041 ... 0x3096: case 0x309d ... 0x309f: case 0x30a1 ... 0x30fa: case 0x30fc ... 0x30ff: case 0x3105 ... 0x312d: case 0x3131 ... 0x318e: case 0x31a0 ... 0x31ba: case 0x31f0 ... 0x31ff: case 0x3400 ... 0x4db5: case 0x4e00 ... 0x9fcc: case 0xa000 ... 0xa48c: case 0xa4d0 ... 0xa4fd: case 0xa500 ... 0xa60c: case 0xa610 ... 0xa61f: case 0xa62a: case 0xa62b: case 0xa640 ... 0xa66e: case 0xa67f ... 0xa69d: case 0xa6a0 ... 0xa6ef: case 0xa717 ... 0xa71f: case 0xa722 ... 0xa788: case 0xa78b ... 0xa78e: case 0xa790 ... 0xa7ad: case 0xa7b0: case 0xa7b1: case 0xa7f7 ... 0xa801: case 0xa803 ... 0xa805: case 0xa807 ... 0xa80a: case 0xa80c ... 0xa822: case 0xa840 ... 0xa873: case 0xa882 ... 0xa8b3: case 0xa8f2 ... 0xa8f7: case 0xa8fb: case 0xa90a ... 0xa925: case 0xa930 ... 0xa946: case 0xa960 ... 0xa97c: case 0xa984 ... 0xa9b2: case 0xa9cf: case 0xa9e0 ... 0xa9e4: case 0xa9e6 ... 0xa9ef: case 0xa9fa ... 0xa9fe: case 0xaa00 ... 0xaa28: case 0xaa40 ... 0xaa42: case 0xaa44 ... 0xaa4b: case 0xaa60 ... 0xaa76: case 0xaa7a: case 0xaa7e ... 0xaaaf: case 0xaab1: case 0xaab5: case 0xaab6: case 0xaab9 ... 0xaabd: case 0xaac0: case 0xaac2: case 0xaadb ... 0xaadd: case 0xaae0 ... 0xaaea: case 0xaaf2 ... 0xaaf4: case 0xab01 ... 0xab06: case 0xab09 ... 0xab0e: case 0xab11 ... 0xab16: case 0xab20 ... 0xab26: case 0xab28 ... 0xab2e: case 0xab30 ... 0xab5a: case 0xab5c ... 0xab5f: case 0xab64: case 0xab65: case 0xabc0 ... 0xabe2: case 0xac00 ... 0xd7a3: case 0xd7b0 ... 0xd7c6: case 0xd7cb ... 0xd7fb: case 0xf900 ... 0xfa6d: case 0xfa70 ... 0xfad9: case 0xfb00 ... 0xfb06: case 0xfb13 ... 0xfb17: case 0xfb1d: case 0xfb1f ... 0xfb28: case 0xfb2a ... 0xfb36: case 0xfb38 ... 0xfb3c: case 0xfb3e: case 0xfb40: case 0xfb41: case 0xfb43: case 0xfb44: case 0xfb46 ... 0xfbb1: case 0xfbd3 ... 0xfd3d: case 0xfd50 ... 0xfd8f: case 0xfd92 ... 0xfdc7: case 0xfdf0 ... 0xfdfb: case 0xfe70 ... 0xfe74: case 0xfe76 ... 0xfefc: case 0xff21 ... 0xff3a: case 0xff41 ... 0xff5a: case 0xff66 ... 0xffbe: case 0xffc2 ... 0xffc7: case 0xffca ... 0xffcf: case 0xffd2 ... 0xffd7: case 0xffda ... 0xffdc: case 0x300 ... 0x36f: case 0x483 ... 0x487: case 0x591 ... 0x5bd: case 0x5bf: case 0x5c1: case 0x5c2: case 0x5c4: case 0x5c5: case 0x5c7: case 0x610 ... 0x61a: case 0x64b ... 0x669: case 0x670: case 0x6d6 ... 0x6dc: case 0x6df ... 0x6e4: case 0x6e7: case 0x6e8: case 0x6ea ... 0x6ed: case 0x6f0 ... 0x6f9: case 0x711: case 0x730 ... 0x74a: case 0x7a6 ... 0x7b0: case 0x7c0 ... 0x7c9: case 0x7eb ... 0x7f3: case 0x816 ... 0x819: case 0x81b ... 0x823: case 0x825 ... 0x827: case 0x829 ... 0x82d: case 0x859 ... 0x85b: case 0x8e4 ... 0x903: case 0x93a ... 0x93c: case 0x93e ... 0x94f: case 0x951 ... 0x957: case 0x962: case 0x963: case 0x966 ... 0x96f: case 0x981 ... 0x983: case 0x9bc: case 0x9be ... 0x9c4: case 0x9c7: case 0x9c8: case 0x9cb ... 0x9cd: case 0x9d7: case 0x9e2: case 0x9e3: case 0x9e6 ... 0x9ef: case 0xa01 ... 0xa03: case 0xa3c: case 0xa3e ... 0xa42: case 0xa47: case 0xa48: case 0xa4b ... 0xa4d: case 0xa51: case 0xa66 ... 0xa71: case 0xa75: case 0xa81 ... 0xa83: case 0xabc: case 0xabe ... 0xac5: case 0xac7 ... 0xac9: case 0xacb ... 0xacd: case 0xae2: case 0xae3: case 0xae6 ... 0xaef: case 0xb01 ... 0xb03: case 0xb3c: case 0xb3e ... 0xb44: case 0xb47: case 0xb48: case 0xb4b ... 0xb4d: case 0xb56: case 0xb57: case 0xb62: case 0xb63: case 0xb66 ... 0xb6f: case 0xb82: case 0xbbe ... 0xbc2: case 0xbc6 ... 0xbc8: case 0xbca ... 0xbcd: case 0xbd7: case 0xbe6 ... 0xbef: case 0xc00 ... 0xc03: case 0xc3e ... 0xc44: case 0xc46 ... 0xc48: case 0xc4a ... 0xc4d: case 0xc55: case 0xc56: case 0xc62: case 0xc63: case 0xc66 ... 0xc6f: case 0xc81 ... 0xc83: case 0xcbc: case 0xcbe ... 0xcc4: case 0xcc6 ... 0xcc8: case 0xcca ... 0xccd: case 0xcd5: case 0xcd6: case 0xce2: case 0xce3: case 0xce6 ... 0xcef: case 0xd01 ... 0xd03: case 0xd3e ... 0xd44: case 0xd46 ... 0xd48: case 0xd4a ... 0xd4d: case 0xd57: case 0xd62: case 0xd63: case 0xd66 ... 0xd6f: case 0xd82: case 0xd83: case 0xdca: case 0xdcf ... 0xdd4: case 0xdd6: case 0xdd8 ... 0xddf: case 0xde6 ... 0xdef: case 0xdf2: case 0xdf3: case 0xe31: case 0xe34 ... 0xe3a: case 0xe47 ... 0xe4e: case 0xe50 ... 0xe59: case 0xeb1: case 0xeb4 ... 0xeb9: case 0xebb: case 0xebc: case 0xec8 ... 0xecd: case 0xed0 ... 0xed9: case 0xf18: case 0xf19: case 0xf20 ... 0xf29: case 0xf35: case 0xf37: case 0xf39: case 0xf3e: case 0xf3f: case 0xf71 ... 0xf84: case 0xf86: case 0xf87: case 0xf8d ... 0xf97: case 0xf99 ... 0xfbc: case 0xfc6: case 0x102b ... 0x103e: case 0x1040 ... 0x1049: case 0x1056 ... 0x1059: case 0x105e ... 0x1060: case 0x1062 ... 0x1064: case 0x1067 ... 0x106d: case 0x1071 ... 0x1074: case 0x1082 ... 0x108d: case 0x108f ... 0x109d: case 0x135d ... 0x135f: case 0x1712 ... 0x1714: case 0x1732 ... 0x1734: case 0x1752: case 0x1753: case 0x1772: case 0x1773: case 0x17b4 ... 0x17d3: case 0x17dd: case 0x17e0 ... 0x17e9: case 0x180b ... 0x180d: case 0x1810 ... 0x1819: case 0x18a9: case 0x1920 ... 0x192b: case 0x1930 ... 0x193b: case 0x1946 ... 0x194f: case 0x19b0 ... 0x19c0: case 0x19c8: case 0x19c9: case 0x19d0 ... 0x19d9: case 0x1a17 ... 0x1a1b: case 0x1a55 ... 0x1a5e: case 0x1a60 ... 0x1a7c: case 0x1a7f ... 0x1a89: case 0x1a90 ... 0x1a99: case 0x1ab0 ... 0x1abd: case 0x1b00 ... 0x1b04: case 0x1b34 ... 0x1b44: case 0x1b50 ... 0x1b59: case 0x1b6b ... 0x1b73: case 0x1b80 ... 0x1b82: case 0x1ba1 ... 0x1bad: case 0x1bb0 ... 0x1bb9: case 0x1be6 ... 0x1bf3: case 0x1c24 ... 0x1c37: case 0x1c40 ... 0x1c49: case 0x1c50 ... 0x1c59: case 0x1cd0 ... 0x1cd2: case 0x1cd4 ... 0x1ce8: case 0x1ced: case 0x1cf2 ... 0x1cf4: case 0x1cf8: case 0x1cf9: case 0x1dc0 ... 0x1df5: case 0x1dfc ... 0x1dff: case 0x200c: case 0x200d: case 0x203f: case 0x2040: case 0x2054: case 0x20d0 ... 0x20dc: case 0x20e1: case 0x20e5 ... 0x20f0: case 0x2cef ... 0x2cf1: case 0x2d7f: case 0x2de0 ... 0x2dff: case 0x302a ... 0x302f: case 0x3099: case 0x309a: case 0xa620 ... 0xa629: case 0xa66f: case 0xa674 ... 0xa67d: case 0xa69f: case 0xa6f0: case 0xa6f1: case 0xa802: case 0xa806: case 0xa80b: case 0xa823 ... 0xa827: case 0xa880: case 0xa881: case 0xa8b4 ... 0xa8c4: case 0xa8d0 ... 0xa8d9: case 0xa8e0 ... 0xa8f1: case 0xa900 ... 0xa909: case 0xa926 ... 0xa92d: case 0xa947 ... 0xa953: case 0xa980 ... 0xa983: case 0xa9b3 ... 0xa9c0: case 0xa9d0 ... 0xa9d9: case 0xa9e5: case 0xa9f0 ... 0xa9f9: case 0xaa29 ... 0xaa36: case 0xaa43: case 0xaa4c: case 0xaa4d: case 0xaa50 ... 0xaa59: case 0xaa7b ... 0xaa7d: case 0xaab0: case 0xaab2 ... 0xaab4: case 0xaab7: case 0xaab8: case 0xaabe: case 0xaabf: case 0xaac1: case 0xaaeb ... 0xaaef: case 0xaaf5: case 0xaaf6: case 0xabe3 ... 0xabea: case 0xabec: case 0xabed: case 0xabf0 ... 0xabf9: case 0xfb1e: case 0xfe00 ... 0xfe0f: case 0xfe20 ... 0xfe2d: case 0xfe33: case 0xfe34: case 0xfe4d ... 0xfe4f: case 0xff10 ... 0xff19: case 0xff3f: break; default: return false; } } return true; };*/

  // Whether a single character denotes a newline.

/*C bool newline (std::string arg) { for (size_t i=0;i<arg.length();i++) { switch (arg[i]) {  break; default: return false; } } return true; };*/

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

/*C bool lineBreak (std::string arg) { for (size_t i=0;i<arg.length();i++) { switch (arg[i]) {  case 0x20: case 0x76: case 0x61: case 0x72: case 0x6c: case 0x69: case 0x6e: case 0x65: case 0x42: case 0x6b: case 0x3d: case 0x2f: case 0x7c: case 0x5b: break; default: return false; } } return true; };*/

  // Test whether a given character code starts an identifier.

  auto isIdentifierStart (auto code) {
    if (code < 65) {
return code == 36;
}
    if (code < 91) {
return true;
}
    if (code < 97) {
return code == 95;
}
    if (code < 123) {
return true;
}
    return code >= 0xaa && test(nonASCIIidentifierStart, fromCharCode(code));
  };

  // Test whether a given character is part of an identifier.

  auto isIdentifierChar (auto code) {
    if (code < 48) {
return code == 36;
}
    if (code < 58) {
return true;
}
    if (code < 65) {
return false;
}
    if (code < 91) {
return true;
}
    if (code < 97) {
return code == 95;
}
    if (code < 123) {
return true;
}
    return code >= 0xaa && test(nonASCIIidentifier, fromCharCode(code));
  };

  // ## Tokenizer

  // These are used when `options.locations` is on, for the
  // `tokStartLoc` and `tokEndLoc` properties.

  auto Position() {
    THIS.line = tokCurLine;
    THIS.column = tokPos - tokLineStart;
  }

  // Reset the token state. Used at the start of a parse.

  auto initTokenState() {
    tokCurLine = 1;
    tokPos = tokLineStart = 0;
    tokRegexpAllowed = true;
    skipSpace();
  }

  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and
  // `tokRegexpAllowed`, and skips the space after the token, so that
  // the next one's `tokStart` will point at the right position.

  void finishToken(keyword_t type, struct js_t val) {
    tokEnd = tokPos;
    if (options.locations) {
tokEndLoc = Position;
}
    tokType = type;
    skipSpace();
    
    tokRegexpAllowed = type.beforeExpr;
  }

  auto skipBlockComment() {
    auto startLoc = options.onComment && options.locations && Position; 
    auto start = tokPos;  auto end = indexOf(input, "*/", tokPos += 2); 
    if (end == -1) {
raise(tokPos - 2, "Unterminated comment");
}
    tokPos = end + 2;
    if (options.locations) {
{

      auto match = RegExpVector(); 
      while ((match = exec(lineBreak, input)) && match.index < tokPos) {
        ++tokCurLine;
        tokLineStart = match.index + match[0].length();
      }
    }
}
    if (options.onComment) {
onComment(options, true, slice(input, start + 2, end), start, tokPos,
                        startLoc, options.locations && Position);
}
  }

  auto skipLineComment() {
    auto start = tokPos; 
    auto startLoc = options.onComment && options.locations && Position; 
    auto ch = charCodeAt(input, tokPos+=2); 
    while (tokPos < inputLen && ch != 10 && ch != 13 && ch != 8232 && ch != 8233) {
      ++tokPos;
      ch = charCodeAt(input, tokPos);
    }
    if (options.onComment) {
onComment(options, false, slice(input, start + 2, tokPos), start, tokPos,
                        startLoc, options.locations && Position);
}
  }

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  void skipSpace() {
    while (tokPos < inputLen) {
      auto ch = charCodeAt(input, tokPos); 
      if (ch == 32) {
{ // ' '
        ++tokPos;
      }
} else if (ch == 13) {
{
        ++tokPos;
        auto next = charCodeAt(input, tokPos); 
        if (next == 10) {
{
          ++tokPos;
        }
}
        if (options.locations) {
{
          ++tokCurLine;
          tokLineStart = tokPos;
        }
}
      }
} else if (LOGICALOR(LOGICALOR(ch == 10,ch == 8232),ch == 8233)) {
{
        ++tokPos;
        if (options.locations) {
{
          ++tokCurLine;
          tokLineStart = tokPos;
        }
}
      }
} else if (ch > 8 && ch < 14) {
{
        ++tokPos;
      }
} else if (ch == 47) {
{ // '/'
        auto next = charCodeAt(input, tokPos + 1); 
        if (next == 42) {
{ // '*'
          skipBlockComment();
        }
} else if (next == 47) {
{ // '/'
          skipLineComment();
        }
} else break;
      }
} else if (ch == 160) {
{ // '\xa0'
        ++tokPos;
      }
} else if (ch >= 5760 && test(nonASCIIwhitespace, fromCharCode(ch))) {
{
        ++tokPos;
      }
} else {
        break;
      }
    }
  }

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because opr parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  // The `forceRegexp` parameter is used in the one case where the
  // `tokRegexpAllowed` trick does not work. See `parseStatement`.

  auto readToken_dot() {
    auto next = charCodeAt(input, tokPos + 1); 
    if (next >= 48 && next <= 57) {
return readNumber(true);
}
    auto next2 = charCodeAt(input, tokPos + 2); 
    if (options.ecmaVersion >= 6 && next == 46 && next2 == 46) {
{ // 46 = dot '.'
      tokPos += 3;
      return finishToken(_ellipsis);
    }
} else {
      ++tokPos;
      return finishToken(_dot);
    }
  }

  void readToken_slash() { // '/'
    auto next = charCodeAt(input, tokPos + 1); 
    if (tokRegexpAllowed) {
{++tokPos; return readRegexp();}
}
    if (next == 61) {
return finishOp(_assign, 2);
}
    return finishOp(_slash, 1);
  }

  auto readToken_mult_modulo() { // '%*'
    auto next = charCodeAt(input, tokPos + 1); 
    if (next == 61) {
return finishOp(_assign, 2);
}
    return finishOp(_multiplyModulo, 1);
  }

  auto readToken_pipe_amp(auto code) { // '|&'
    auto next = charCodeAt(input, tokPos + 1); 
    if (next == code) {
return finishOp(code == 124 ? _logicalOR : _logicalAND, 2);
}
    if (next == 61) {
return finishOp(_assign, 2);
}
    return finishOp(code == 124 ? _bitwiseOR : _bitwiseAND, 1);
  }

  auto readToken_caret() { // '^'
    auto next = charCodeAt(input, tokPos + 1); 
    if (next == 61) {
return finishOp(_assign, 2);
}
    return finishOp(_bitwiseXOR, 1);
  }

  auto readToken_plus_min(auto code) { // '+-'
    auto next = charCodeAt(input, tokPos + 1); 
    if (next == code) {
{
      if (next == 45 && charCodeAt(input, tokPos + 2) == 62 &&
          test(newline, slice(input, lastEnd, tokPos))) {
{
        // A `-->` line comment
        tokPos += 3;
        skipLineComment();
        skipSpace();
        return readToken();
      }
}
      return finishOp(_incDec, 2);
    }
}
    if (next == 61) {
return finishOp(_assign, 2);
}
    return finishOp(_plusMin, 1);
  }

  auto readToken_lt_gt(auto code) { // '<>'
    auto next = charCodeAt(input, tokPos + 1); 
    int size = 1; 
    if (next == code) {
{
      size = code == 62 && charCodeAt(input, tokPos + 2) == 62 ? 3 : 2;
      if (charCodeAt(input, tokPos + size) == 61) {
return finishOp(_assign, size + 1);
}
      return finishOp(_bitShift, size);
    }
}
    if (next == 33 && code == 60 && charCodeAt(input, tokPos + 2) == 45 &&
        charCodeAt(input, tokPos + 3) == 45) {
{
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      tokPos += 4;
      skipLineComment();
      skipSpace();
      return readToken();
    }
}
    if (next == 61) {
size = charCodeAt(input, tokPos + 2) == 61 ? 3 : 2;
}
    return finishOp(_relational, size);
  }

  auto readToken_eq_excl(auto code) { // '=!'
    auto next = charCodeAt(input, tokPos + 1); 
    if (next == 61) {
return finishOp(_equality, charCodeAt(input, tokPos + 2) == 61 ? 3 : 2);
}
    return finishOp(code == 61 ? _eq : _prefix, 1);
  }

  bool getTokenFromCode(int code) {
    switch(code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
    case 46:{ // '.'
      return readToken_dot();}

      // Punctuation tokens.
    case 40:{ ++tokPos; return finishToken(_parenL);}
    case 41:{ ++tokPos; return finishToken(_parenR);}
    case 59:{ ++tokPos; return finishToken(_semi);}
    case 44:{ ++tokPos; return finishToken(_comma);}
    case 91:{ ++tokPos; return finishToken(_bracketL);}
    case 93:{ ++tokPos; return finishToken(_bracketR);}
    case 123:{ ++tokPos; return finishToken(_braceL);}
    case 125:{ ++tokPos; return finishToken(_braceR);}
    case 58:{ ++tokPos; return finishToken(_colon);}
    case 63:{ ++tokPos; return finishToken(_question);}

      // '0x' is a hexadecimal number.
    case 48:{ // '0'
      auto next = charCodeAt(input, tokPos + 1); 
      if (LOGICALOR(next == 120,next == 88)) {
return readHexNumber();
}}
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
    case 49:{} case 50:{} case 51:{} case 52:{} case 53:{} case 54:{} case 55:{} case 56:{} case 57:{ // 1-9
      return readNumber(false);}

      // Quotes produce strings.
    case 34:{} case 39:{ // '"', "'"
      return readString(code);}

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47:{ // '/'
      return readToken_slash();}

    case 37:{} case 42:{ // '%*'
      return readToken_mult_modulo();}

    case 124:{} case 38:{ // '|&'
      return readToken_pipe_amp(code);}

    case 94:{ // '^'
      return readToken_caret();}

    case 43:{} case 45:{ // '+-'
      return readToken_plus_min(code);}

    case 60:{} case 62:{ // '<>'
      return readToken_lt_gt(code);}

    case 61:{} case 33:{ // '=!'
      return readToken_eq_excl(code);}

    case 126:{ // '~'
      return finishOp(_prefix, 1);}
    }

return true;
  }

  void readToken(bool forceRegexp) {
    if (!forceRegexp) {
tokStart = tokPos;
} else tokPos = tokStart + 1;
    if (options.locations) {
tokStartLoc = Position;
}
    if (forceRegexp) {
return readRegexp();
}
    if (tokPos >= inputLen) {
return finishToken(_eof);
}

    auto code = charCodeAt(input, tokPos); 
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (LOGICALOR(isIdentifierStart(code),code == 92)) {
return readWord();
}

    auto tok = getTokenFromCode(code); 

if (tok == true) {
{
      // If we are here, we either found a non-ASCII identifier
      // character, or something that's entirely disallowed.
      auto ch = fromCharCode(code); 
      if (LOGICALOR(ch == "\\",test(nonASCIIidentifierStart, ch))) {
return readWord();
}
      raise(tokPos, std::string("Unexpected character '") + ch + std::string("'"));
    }
}
    return tok;
  }

  void finishOp(keyword_t type, int size) {
    auto str = slice(input, tokPos, tokPos + size); 
    tokPos += size;
    finishToken(type, str);
  }

  // Parse a regular expression. Some context-awareness is necessary,
  // since a '/' inside a '[]' set does not end the expression.

  void readRegexp() {
    std::string content = "";  auto escaped = 0;  auto inClass = 0;  auto start = tokPos; 
    ; for (; ;)
{
      if (tokPos >= inputLen) {
raise(start, "Unterminated regular expression");
}
      auto ch = charAt(input, tokPos); 
      if (test(newline, ch)) {
raise(start, "Unterminated regular expression");
}
      if (!escaped) {
{
        if (ch == "[") {
inClass = true;
} else if (ch == "]" && inClass) {
inClass = false;
} else if (ch == "/" && !inClass) {
break;
}
        escaped = ch == "\\";
      }
} else escaped = false;
      ++tokPos;
    }
    content = slice(input, start, tokPos); 
    ++tokPos;
    // Need to use `readWord1` because '\uXXXX' sequences are allowed
    // here (don't ask).
    auto mods = readWord1(); 
    if (mods && !test(RegExp("[object Object]"), mods)) {
raise(start, "Invalid regular expression flag");
}
    // try {
    //   var value = RegExp(content, mods);
    // } catch (e) {
    //   if (e instanceof SyntaxError) raise(start, "Error parsing regular expression: " + e.message);
    //   raise(e);
    // }
    auto value = RegExp(content, mods); 
    if (ISNULL(value)) {
{
      raise(0, 'SyntaxError');
    }
}
    return finishToken(_regexp, value);
  }

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  int readInt(int radix, int len) {
    auto start = tokPos;  auto total = 0; 
    auto i = 0;  auto e = ISNULL(len) ? Infinity : len; ; for (; i < e;)
{
      auto code = charCodeAt(input, tokPos);  auto val = 0; 
      if (code >= 97) {
val = code - 97 + 10;
} else if (code >= 65) {
val = code - 65 + 10;
} else if (code >= 48 && code <= 57) {
val = code - 48;
} else val = Infinity;
      if (val >= radix) {
break;
}
      ++tokPos;
      total = total * radix + val;
    }
    if (LOGICALOR(tokPos == start,ISNOTNULL(len) && tokPos - start != len)) {
return DBL_NULL;
}

    return total;
  }

  int readHexNumber() {
    tokPos += 2; // 0x
    auto val = readInt(16); 
    if (ISNULL(val)) {
raise(tokStart + 2, "Expected hexadecimal number");
}
    if (isIdentifierStart(charCodeAt(input, tokPos))) {
raise(tokPos, "Identifier directly after number");
}
    return finishToken(_num, val);
  }

  // Read an integer, octal integer, or floating-point number.

  void readNumber(bool startsWithDot) {
    auto start = tokPos;  auto isFloat = false;  auto octal = charCodeAt(input, tokPos) == 48; 
    if (!startsWithDot && ISNULL(readInt(10))) {
raise(start, "Invalid number");
}
    if (charCodeAt(input, tokPos) == 46) {
{
      ++tokPos;
      readInt(10);
      isFloat = true;
    }
}
    auto next = charCodeAt(input, tokPos); 
    if (LOGICALOR(next == 69,next == 101)) {
{ // 'eE'
      next = charCodeAt(input, ++tokPos);
      if (LOGICALOR(next == 43,next == 45)) {
++tokPos;
} // '+-'
      if (ISNULL(readInt(10))) {
raise(start, "Invalid number");
}
      isFloat = true;
    }
}
    if (isIdentifierStart(charCodeAt(input, tokPos))) {
raise(tokPos, "Identifier directly after number");
}

    auto str = slice(input, start, tokPos);  auto val = 0; 
    if (isFloat) {
val = parseFloat(str);
} else if (LOGICALOR(!octal,str.length() == 1)) {
val = parseInt(str, 10);
} else if (LOGICALOR(test(RegExp("[object Object]"), str),strict)) {
raise(start, "Invalid number");
} else val = parseInt(str, 8);
    return finishToken(_num, val);
  }

  // Read a string value, interpreting backslash-escapes.

  void readString(int quote) {
    tokPos++;
    std::string out = ""; 
    ; for (; ;)
{
      if (tokPos >= inputLen) {
raise(tokStart, "Unterminated string constant");
}
      auto ch = charCodeAt(input, tokPos); 
      if (ch == quote) {
{
        ++tokPos;
        return finishToken(_string, out);
      }
}
      if (ch == 92) {
{ // '\'
        ch = charCodeAt(input, ++tokPos);
        auto octal = exec(RegExp("[object Object]"), slice(input, tokPos, tokPos + 3))[0]; 
        while (octal && parseInt(octal, 8) > 255) octal = slice(octal, 0, -1);
        if (octal == "0") {
octal = null;
}
        ++tokPos;
        if (octal.length() > 0) {
{
          if (strict) {
raise(tokPos - 2, "Octal literal in strict mode");
}
          out += fromCharCode(parseInt(octal, 8));
          tokPos += octal.length() - 1;
        }
} else {
          switch (ch) {
          case 110:{ out += "\n"; break;} // 'n' -> '\n'
          case 114:{ out += "\r"; break;} // 'r' -> '\r'
          case 120:{ out += fromCharCode(readHexChar(2)); break;} // 'x'
          case 117:{ out += fromCharCode(readHexChar(4)); break;} // 'u'
          case 85:{ out += fromCharCode(readHexChar(8)); break;} // 'U'
          case 116:{ out += "\t"; break;} // 't' -> '\t'
          case 98:{ out += "\b"; break;} // 'b' -> '\b'
          case 118:{ out += "\u000b"; break;} // 'v' -> '\u000b'
          case 102:{ out += "\f"; break;} // 'f' -> '\f'
          case 48:{ out += "\0"; break;} // 0 -> '\0'
          case 13:{ if (charCodeAt(input, tokPos) == 10) {
++tokPos;
}} // '\r\n'
          case 10:{ // ' \n'
            if (options.locations) {
{ tokLineStart = tokPos; ++tokCurLine; }
}
            break;}
          default:{ out += fromCharCode(ch); break;}
          }
        }
      }
} else {
        if (LOGICALOR(LOGICALOR(LOGICALOR(ch == 13,ch == 10),ch == 8232),ch == 8233)) {
raise(tokStart, "Unterminated string constant");
}
        out += fromCharCode(ch); // '\'
        ++tokPos;
      }
    }
  }

  // Used to read character escape sequences ('\x', '\u', '\U').

  int readHexChar(int len) {
    auto n = readInt(16, len); 
    if (ISNULL(n)) {
raise(tokStart, "Bad character escape sequence");
}
    return n;
  }

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.

  auto containsEsc = 0; 

  // Read an identifier, and return it as a string. Sets `containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Only builds up the word character-by-character when it actually
  // containeds an escape, as a micro-optimization.

  std::string readWord1() {
    containsEsc = false;
    std::string word = std::string("");  auto first = true;  auto start = tokPos; 
    ; for (; ;)
{
      auto ch = charCodeAt(input, tokPos); 
      if (isIdentifierChar(ch)) {
{
        if (containsEsc) {
word += charAt(input, tokPos);
}
        ++tokPos;
      }
} else if (ch == 92) {
{ // "\"
        if (!containsEsc) {
word = slice(input, start, tokPos);
}
        containsEsc = true;
        if (charCodeAt(input, ++tokPos) != 117) {
raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
}
        ++tokPos;
        auto esc = readHexChar(4); 
        auto escStr = fromCharCode(esc); 
        if (!escStr) {
raise(tokPos - 1, "Invalid Unicode escape");
}
        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) {
raise(tokPos - 4, "Invalid Unicode escape");
}
        word += escStr;
      }
} else {
        break;
      }
      first = false;
    }
    return containsEsc ? word : slice(input, start, tokPos);
  }

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  void readWord() {
    std::string word = readWord1(); 
    keyword_t type = _name; 
    if (!containsEsc && isKeyword(word)) {
type = keywordTypes(word);
}
    return finishToken(type, word);
  }

  // ## Parser

  // A recursive descent parser operates by defining functions for all
  // syntactic elements, and recursively calling those, each function
  // advancing the input stream and returning an AST node. Precedence
  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
  // instead of `(!x)[1]` is handled by the fact that the parser
  // function that parses unary prefix operators is called first, and
  // in turn calls the function that parses `[]` subscripts  that
  // way, it'll receive the node for `x[1]` already parsed, and wraps
  // *that* in the unary opr node.
  //
  // Acorn uses an [opr precedence parser][opp] to handle binary
  // opr precedence, because it is much more compact than using
  // the technique outlined above, which uses different, nesting
  // functions to specify precedence, for all of the ten binary
  // precedence levels that JavaScript defines.
  //
  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

  // ### Parser utilities

  // Continue to the next token.

  auto next() {
    lastStart = tokStart;
    lastEnd = tokEnd;
    lastEndLoc = tokEndLoc;
    readToken();
  }

  // Enter strict mode. Re-reads the next token to please pedantic
  // tests ("use strict"; 010; -- should fail).

  auto setStrict(auto strct) {
    strict = strct;
    tokPos = tokStart;
    if (options.locations) {
{
      while (tokPos < tokLineStart) {
        tokLineStart = lastIndexOf(input, "\n", tokLineStart - 2) + 1;
        --tokCurLine;
      }
    }
}
    skipSpace();
    readToken();
  }

















  Node* startNode() {
    auto node = new Node(); 
    if (options.locations) {
node->loc = new SourceLocation();
}
    if (options.directSourceFile.length() > 0) {
node->sourceFile = options.directSourceFile;
}
    if (options.ranges) {
node->range = std::vector<int>(tokStart, 0);
}
    return node;
  }

  // Start a node whose start offset information should be based on
  // the start of another node. For example, a binary opr node is
  // only started after its left-hand side has already been parsed.

  auto startNodeFrom(auto other) {
    auto node = new Node(); 
    node->start = other->start;
    if (options.locations) {
{
      node->loc = new SourceLocation();
      node->loc->start = other->loc->start;
    }
}
    if (options.ranges) {
node->range = std::vector<int>(other->range[0], 0);
}

    return node;
  }

  // Finish an AST node, adding `type` and `end` properties.

  Node* finishNode(Node* node, std::string type) {
    node->type = type;
    node->end = lastEnd;
    if (options.locations) {
node->loc->end = lastEndLoc;
}
    if (options.ranges) {
node->range[1] = lastEnd;
}
    /*C printf("type %s\n", type.c_str()); */
    return LOGICALOR(0,node);
  }

  // Test whether a statement node is the string literal `"use strict"`.

  bool isUseStrict(Node* stmt) {
    return options.ecmaVersion >= 5 && stmt->type == "ExpressionStatement" &&
      stmt->expression->type == "Literal" && stmt->expression->value == "use strict";
  }

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  auto eat(keyword_t type) {
    if (tokType == type) {
{
      next();
      return true;
    }
}
  }

  // Test whether a semicolon can be inserted at the current position.

  auto canInsertSemicolon() {
    return !options.strictSemicolons &&
      (LOGICALOR(LOGICALOR(tokType == _eof,tokType == _braceR),test(newline, slice(input, lastEnd, tokStart))));
  }

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  auto semicolon() {
    if (!eat(_semi) && !canInsertSemicolon()) {
unexpected();
}
  }

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  auto expect(auto type) {
    if (tokType == type) {
next();
} else unexpected();
  }

  // Raise an unexpected token error.

  void* unexpected() {
    raise(tokStart, "Unexpected token");
    /*C return nullptr;*/
  }

  // Verify that a node is an lval  something that can be assigned
  // to.

  auto checkLVal(auto expr) {
    if (expr->type != "Identifier" && expr->type != "MemberExpression") {
raise(expr->start, "Assigning to rvalue");
}
    if (strict && expr->type == "Identifier" && isStrictBadIdWord(expr->name)) {
raise(expr->start, std::string("Assigning to ") + expr->name + std::string(" in strict mode"));
}
  }

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new node.

  Node* parseTopLevel(Node* program) {
    lastStart = lastEnd = tokPos;
    if (options.locations) {
lastEndLoc = Position;
}
    inFunction = strict = null;
    labels = std::vector<label_t>();
    readToken();

    auto node = LOGICALOR(program,startNode());  auto first = true; 
    if (!program) {
node->bodyarr = std::vector<Node*>();
}
    while (tokType != _eof) {
      auto stmt = parseStatement(); 
      push(node->bodyarr, stmt);
      if (first && isUseStrict(stmt)) {
setStrict(true);
}
      first = false;
    }
    return finishNode(node, "Program");
  }

  label_t loopLabel = {kind: "loop"};  label_t switchLabel = {kind: "switch"}; 

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash opr, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo);`, where looking at the previous token
  // does not help.

  Node* parseStatement() {
    if (LOGICALOR(tokType == _slash,tokType == _assign && tokVal == "/=")) {
readToken(true);
}

    auto starttype = tokType;  auto node = startNode(); 

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype._id) {
    case _break:{} case _continue:{ return parseBreakContinueStatement(node, starttype.keyword);}
    case _debugger:{ return parseDebuggerStatement(node);}
    case _do:{ return parseDoStatement(node);}
    case _for:{ return parseForStatement(node);}
    case _function:{ return parseFunctionStatement(node);}
    case _if:{ return parseIfStatement(node);}
    case _return:{ return parseReturnStatement(node);}
    case _switch:{ return parseSwitchStatement(node);}
    case _throw:{ return parseThrowStatement(node);}
    case _try:{ return parseTryStatement(node);}
    case _var:{} case _let:{} case _const:{ return parseVarStatement(node, starttype.keyword);}
    case _while:{ return parseWhileStatement(node);}
    case _with:{ return parseWithStatement(node);}
    case _braceL:{ return parseBlock();} // no point creating a function for this
    case _semi:{ return parseEmptyStatement(node);}

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
    default:{
      auto maybeName = tokVal;  auto expr = parseExpression(); 
      if (starttype == _name && expr->type == "Identifier" && eat(_colon)) {
return parseLabeledStatement(node, maybeName, expr);
} else return parseExpressionStatement(node, expr);}
    }
  }
  
  Node* parseBreakContinueStatement(Node* node, std::string keyword) {
    auto isBreak = keyword == "break"; 
    next();
    if (LOGICALOR(eat(_semi),canInsertSemicolon())) {
node->label = null;
} else if (tokType != _name) {
unexpected();
} else {
      node->label = parseIdent();
      semicolon();
    }

    // Verify that there is an actual destination to break or
    // continue to.
    auto i = 0; ; for (; i < labels.size();)
{
      auto lab = labels[i]; 
      if (LOGICALOR(ISNULL(node->label),lab.name == node->label->name)) {
{
        if (ISNOTNULL(lab.kind) && (LOGICALOR(isBreak,lab.kind == "loop"))) {
break;
}
        if (node->label && isBreak) {
break;
}
      }
}
    }
    if (i == labels.size()) {
raise(node->start, std::string("Unsyntactic ") + keyword);
}
    return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
  }
  
  Node* parseDebuggerStatement(Node* node) {
    next();
    semicolon();
    return finishNode(node, "DebuggerStatement");
  }
  
  Node* parseDoStatement(Node* node) {
    next();
    push(labels, loopLabel);
    node->body = parseStatement();
    pop(labels);
    expect(_while);
    node->test = parseParenExpression();
    semicolon();
    return finishNode(node, "DoWhileStatement");
  }
  
  // Disambiguating between a `for` and a `for`/`in` loop is
  // non-trivial. Basically, we have to parse the init `var`
  // statement or expression, disallowing the `in` opr (see
  // the second parameter to `parseExpression`), and then check
  // whether the next token is `in`. When there is no init part
  // (semicolon immediately after the opening parenthesis), it is
  // a regular `for` loop.
  
  Node* parseForStatement(Node* node) {
    next();
    push(labels, loopLabel);
    expect(_parenL);
    if (tokType == _semi) {
return parseFor(node, null);
}
    if (LOGICALOR(tokType == _var,tokType == _let)) {
{
      auto init = startNode();  auto varKind = tokType.keyword; 
      next();
      parseVar(init, true, varKind);
      finishNode(init, "VariableDeclaration");
      if (init->declarations.size() == 1 && eat(_in)) {
return parseForIn(node, init);
}
      return parseFor(node, init);
    }
}
    auto init = parseExpression(false, true); 
    if (eat(_in)) {
{checkLVal(init); return parseForIn(node, init);}
}
    return parseFor(node, init);
  }
  
  Node* parseFunctionStatement(Node* node) {
    next();
    return parseFunction(node, true);
  }
  
  Node* parseIfStatement(Node* node) {
    next();
    node->test = parseParenExpression();
    node->consequent = parseStatement();
    node->alternate = eat(_else) ? parseStatement() : null;
    return finishNode(node, "IfStatement");
  }
  
  Node* parseReturnStatement(Node* node) {
    if (!inFunction && !options.allowReturnOutsideFunction) {
raise(tokStart, "'return' outside of function");
}
    next();

    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.

    if (LOGICALOR(eat(_semi),canInsertSemicolon())) {
node->argument = null;
} else { node->argument = parseExpression(); semicolon(); }
    return finishNode(node, "ReturnStatement");
  }
  
  Node* parseSwitchStatement(Node* node) {
    next();
    node->discriminant = parseParenExpression();
    node->cases = std::vector<Node*>();
    expect(_braceL);
    push(labels, switchLabel);

    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.

    Node* cur = nullptr;  auto sawDefault = 0; ; for (; tokType != _braceR;)
{
      if (LOGICALOR(tokType == _case,tokType == _default)) {
{
        auto isCase = tokType == _case; 
        if (cur) {
finishNode(cur, "SwitchCase");
}
        push(node->cases, cur = startNode());
        cur->consequents = std::vector<Node*>();
        next();
        if (isCase) {
cur->test = parseExpression();
} else {
          if (sawDefault) {
raise(lastStart, "Multiple default clauses");
} sawDefault = true;
          cur->test = null;
        }
        expect(_colon);
      }
} else {
        if (!cur) {
unexpected();
}
        push(cur->consequents, parseStatement());
      }
    }
    if (cur) {
finishNode(cur, "SwitchCase");
}
    next(); // Closing brace
    pop(labels);
    return finishNode(node, "SwitchStatement");
  }
  
  Node* parseThrowStatement(Node* node) {
    next();
    if (test(newline, slice(input, lastEnd, tokStart))) {
raise(lastEnd, "Illegal newline after throw");
}
    node->argument = parseExpression();
    semicolon();
    return finishNode(node, "ThrowStatement");
  }
  
  Node* parseTryStatement(Node* node) {
    next();
    node->block = parseBlock();
    node->handler = null;
    if (tokType == _catch) {
{
      auto clause = startNode(); 
      next();
      expect(_parenL);
      clause->param = parseIdent();
      if (strict && isStrictBadIdWord(clause->param->name)) {
raise(clause->param->start, std::string("Binding ") + clause->param->name + std::string(" in strict mode"));
}
      expect(_parenR);
      clause->guard = null;
      clause->body = parseBlock();
      node->handler = finishNode(clause, "CatchClause");
    }
}
    node->guardedHandlers = empty;
    node->finalizer = eat(_finally) ? parseBlock() : null;
    if (!node->handler && !node->finalizer) {
raise(node->start, "Missing catch or finally clause");
}
    return finishNode(node, "TryStatement");
  }
  
  Node* parseVarStatement(Node* node, std::string kind) {
    next();
    parseVar(node, false, kind);
    semicolon();
    return finishNode(node, "VariableDeclaration");
  }
  
  Node* parseWhileStatement(Node* node) {
    next();
    node->test = parseParenExpression();
    push(labels, loopLabel);
    node->body = parseStatement();
    pop(labels);
    return finishNode(node, "WhileStatement");
  }
  
  Node* parseWithStatement(Node* node) {
    if (strict) {
raise(tokStart, "'with' in strict mode");
}
    next();
    node->object = parseParenExpression();
    node->body = parseStatement();
    return finishNode(node, "WithStatement");
  }
  
  Node* parseEmptyStatement(Node* node) {
    next();
    return finishNode(node, "EmptyStatement");
  }
  
  Node* parseLabeledStatement(Node* node, std::string maybeName, Node* expr) {
    auto i = 0; ; for (; i < labels.size();)
if (labels[i].name == maybeName) {
raise(expr->start, std::string("Label '") + maybeName + std::string("' is already declared"));
}
    std::string kind = tokType.isLoop ? "loop" : tokType == _switch ? "switch" : null; 
    push(labels, (label_t){kind: kind, name: maybeName});
    node->body = parseStatement();
    pop(labels);
    node->label = expr;
    return finishNode(node, "LabeledStatement");
  }
  
  Node* parseExpressionStatement(Node* node, Node* expr) {
    node->expression = expr;
    semicolon();
    return finishNode(node, "ExpressionStatement");
  }

  // Used for constructs like `switch` and `if` that insist on
  // parentheses around their expression.

  Node* parseParenExpression() {
    expect(_parenL);
    auto val = parseExpression(); 
    expect(_parenR);
    return val;
  }

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  Node* parseBlock(bool allowStrict) {
    auto node = startNode();  auto first = true;  auto strict = false;  auto oldStrict = 0; 
    node->bodyarr = std::vector<Node*>();
    expect(_braceL);
    while (!eat(_braceR)) {
      auto stmt = parseStatement(); 
      push(node->bodyarr, stmt);
      if (first && allowStrict && isUseStrict(stmt)) {
{
        oldStrict = strict;
        setStrict(strict = true);
      }
}
      first = false;
    }
    if (strict && !oldStrict) {
setStrict(false);
}
    return finishNode(node, "BlockStatement");
  }

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  Node* parseFor(Node* node, Node* init) {
    node->init = init;
    expect(_semi);
    node->test = tokType == _semi ? null : parseExpression();
    expect(_semi);
    node->update = tokType == _parenR ? null : parseExpression();
    expect(_parenR);
    node->body = parseStatement();
    pop(labels);
    return finishNode(node, "ForStatement");
  }

  // Parse a `for`/`in` loop.

  Node* parseForIn(Node* node, Node* init) {
    node->left = init;
    node->right = parseExpression();
    expect(_parenR);
    node->body = parseStatement();
    pop(labels);
    return finishNode(node, "ForInStatement");
  }

  // Parse a list of variable declarations.

  Node* parseVar(Node* node, bool noIn, std::string kind) {
    node->declarations = std::vector<Node*>();
    node->kind = kind;
    ; for (; ;)
{
      auto decl = startNode(); 
      decl->id = parseIdent();
      if (strict && isStrictBadIdWord(decl->id->name)) {
raise(decl->id->start, std::string("Binding ") + decl->id->name + std::string(" in strict mode"));
}
      decl->init = eat(_eq) ? parseExpression(true, noIn) : (kind == _const.keyword ? unexpected() : null);
      push(node->declarations, finishNode(decl, "VariableDeclarator"));
      if (!eat(_comma)) {
break;
}
    }
    return node;
  }

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The arguments are used to forbid comma
  // sequences (in argument lists, array literals, or object literals)
  // or the `in` opr (in for loops initalization expressions).

  Node* parseExpression(bool noComma, bool noIn) {
    auto expr = parseMaybeAssign(noIn); 
    if (!noComma && tokType == _comma) {
{
      auto node = startNodeFrom(expr); 
      node->expressions = std::vector<Node*>(expr);
      while (eat(_comma)) push(node->expressions, parseMaybeAssign(noIn));
      return finishNode(node, "SequenceExpression");
    }
}
    return expr;
  }

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  Node* parseMaybeAssign(bool noIn) {
    auto left = parseMaybeConditional(noIn); 
    if (tokType.isAssign) {
{
      auto node = startNodeFrom(left); 
      node->opr = tokVal;
      node->left = left;
      next();
      node->right = parseMaybeAssign(noIn);
      checkLVal(left);
      return finishNode(node, "AssignmentExpression");
    }
}
    return left;
  }

  // Parse a ternary conditional (`?:`) opr.

  Node* parseMaybeConditional(bool noIn) {
    auto expr = parseExprOps(noIn); 
    if (eat(_question)) {
{
      auto node = startNodeFrom(expr); 
      node->test = expr;
      node->consequent = parseExpression(true);
      expect(_colon);
      node->alternate = parseExpression(true, noIn);
      return finishNode(node, "ConditionalExpression");
    }
}
    return expr;
  }

  // Start the precedence parser.

  Node* parseExprOps(bool noIn) {
    return parseExprOp(parseMaybeUnary(), -1, noIn);
  }

  // Parse binary operators with the opr precedence parsing
  // algorithm. `left` is the left-hand side of the opr.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // opr that has a lower precedence than the set it is parsing.

  Node* parseExprOp(Node* left, double minPrec, bool noIn) {
    auto prec = tokType.binop; 
    if (ISNOTNULL(prec) && (LOGICALOR(!noIn,tokType != _in))) {
{
      if (prec > minPrec) {
{
        auto node = startNodeFrom(left); 
        node->left = left;
        node->opr = tokVal;
        auto op = tokType; 
        next();
        node->right = parseExprOp(parseMaybeUnary(), prec, noIn);
        auto exprNode = finishNode(node, (LOGICALOR(op == _logicalOR,op == _logicalAND)) ? "LogicalExpression" : "BinaryExpression"); 
        return parseExprOp(exprNode, minPrec, noIn);
      }
}
    }
}
    return left;
  }

  // Parse unary operators, both prefix and postfix.

  Node* parseMaybeUnary() {
    if (tokType.prefix) {
{
      auto node = startNode();  auto update = tokType.isUpdate; 
      node->opr = tokVal;
      node->prefix = true;
      tokRegexpAllowed = true;
      next();
      node->argument = parseMaybeUnary();
      if (update) {
checkLVal(node->argument);
} else if (strict && node->opr == "delete" &&
               node->argument->type == "Identifier") {
raise(node->start, "Deleting local variable in strict mode");
}
      return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    }
}
    auto expr = parseExprSubscripts(); 
    while (tokType.postfix && !canInsertSemicolon()) {
      auto node = startNodeFrom(expr); 
      node->opr = tokVal;
      node->prefix = false;
      node->argument = expr;
      checkLVal(expr);
      next();
      expr = finishNode(node, "UpdateExpression");
    }
    return expr;
  }

  // Parse call, dot, and `[]`-subscript expressions.

  Node* parseExprSubscripts() {
    return parseSubscripts(parseExprAtom());
  }

  Node* parseSubscripts(Node* base, bool noCalls) {
    if (eat(_dot)) {
{
      auto node = startNodeFrom(base); 
      node->object = base;
      node->property = parseIdent(true);
      node->computed = false;
      return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
    }
} else if (eat(_bracketL)) {
{
      auto node = startNodeFrom(base); 
      node->object = base;
      node->property = parseExpression();
      node->computed = true;
      expect(_bracketR);
      return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
    }
} else if (!noCalls && eat(_parenL)) {
{
      auto node = startNodeFrom(base); 
      node->callee = base;
      node->arguments = parseExprList(_parenR, false);
      return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
    }
} else return base;
  }

  // Parse an atomic expression  either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  Node* parseExprAtom() {
    switch (tokType._id) {
    case _this:{
      auto node = startNode(); 
      next();
      return finishNode(node, "ThisExpression");}
    case _name:{
      return parseIdent();}
    case _num:{} case _string:{} case _regexp:{
      auto node = startNode(); 
      node->value = tokVal;
      node->raw = slice(input, tokStart, tokEnd);
      next();
      return finishNode(node, "Literal");}

    case _null:{} case _true:{} case _false:{
      auto node = startNode(); 
      node->value = tokType.atomValue;
      node->raw = tokType.keyword;
      next();
      return finishNode(node, "Literal");}

    case _parenL:{
      int tokStartLoc1 = tokStartLoc;  auto tokStart1 = tokStart; 
      next();
      auto val = parseExpression(); 
      val->start = tokStart1;
      val->end = tokEnd;
      if (options.locations) {
{
        val->loc->start = tokStartLoc1;
        val->loc->end = tokEndLoc;
      }
}
      if (options.ranges) {
val->range = std::vector<int>(tokStart1, tokEnd);
}
      expect(_parenR);
      return val;}

    case _bracketL:{
      auto node = startNode(); 
      next();
      node->elements = parseExprList(_bracketR, true, true);
      return finishNode(node, "ArrayExpression");}

    case _braceL:{
      return parseObj();}

    case _function:{
      auto node = startNode(); 
      next();
      return parseFunction(node, false);}

    case _new:{
      return parseNew();}

    default:{
      unexpected();}
    }
  }

  // New's precedence is slightly tricky. It must allow its argument
  // to be a `[]` or dot subscript expression, but not a call  at
  // least, not without wrapping it in parentheses. Thus, it uses the

  Node* parseNew() {
    auto node = startNode(); 
    next();
    node->callee = parseSubscripts(parseExprAtom(), true);
    if (eat(_parenL)) {
node->arguments = parseExprList(_parenR, false);
} else node->arguments = empty;
    return finishNode(node, "NewExpression");
  }

  // Parse an object literal.

  Node* parseObj() {
    auto node = startNode();  auto first = true;  auto sawGetSet = false; 
    node->properties = std::vector<Node*>();
    next();
    while (!eat(_braceR)) {
      if (!first) {
{
        expect(_comma);
        if (options.allowTrailingCommas && eat(_braceR)) {
break;
}
      }
} else first = false;

      Node prop = {}; prop.key = parsePropertyName();  auto isGetSet = false;  std::string kind = std::string(""); 
      if (eat(_colon)) {
{
        prop.value = parseExpression(true);
        kind = prop.kind = "init";
      }
} else if (options.ecmaVersion >= 5 && prop.key->type == "Identifier" &&
                 (LOGICALOR(prop.key->name == "get",prop.key->name == "set"))) {
{
        isGetSet = sawGetSet = true;
        kind = prop.kind = prop.key->name;
        prop.key = parsePropertyName();
        if (tokType != _parenL) {
unexpected();
}
        prop.value = parseFunction(startNode(), false);
      }
} else unexpected();

      // getters and setters are not allowed to clash  either with
      // each other or with an init property  and in strict mode,
      // init properties are also not allowed to be repeated.

      if (prop.key->type == "Identifier" && (LOGICALOR(strict,sawGetSet))) {
{
        auto i = 0; ; for (; i < node->properties.size();)
{
          auto other = node->properties[i]; 
          if (other->key->name == prop.key->name) {
{
            auto conflict = LOGICALOR(LOGICALOR(kind == other->kind,isGetSet && other->kind == "init"),kind == "init" && (LOGICALOR(other->kind == "get",other->kind == "set"))); 
            if (conflict && !strict && kind == "init" && other->kind == "init") {
conflict = false;
}
            if (conflict) {
raise(prop.key->start, "Redefinition of property");
}
          }
}
        }
      }
}
      push(node->properties, &prop);
    }
    return finishNode(node, "ObjectExpression");
  }

  Node* parsePropertyName() {
    if (LOGICALOR(tokType == _num,tokType == _string)) {
return parseExprAtom();
}
    return parseIdent(true);
  }

  // Parse a function declaration or literal (depending on the
  // `isStatement` parameter).

  Node* parseFunction(Node* node, bool isStatement) {
    if (tokType == _name) {
node->id = parseIdent();
} else if (isStatement) {
unexpected();
} else node->id = null;
    node->params = std::vector<Node*>();
    node->rest = null;
    expect(_parenL);
    ; for (; ;)
{
      if (eat(_parenR)) {
{
        break;
      }
} else if (options.ecmaVersion >= 6 && eat(_ellipsis)) {
{
        node->rest = parseIdent();
        expect(_parenR);
        break;
      }
} else {
        push(node->params, parseIdent());
        if (!eat(_comma)) {
{
          expect(_parenR);
          break;
        }
}
      }
    }

    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    auto oldInFunc = inFunction;  auto oldLabels = labels; 
    inFunction = true; labels = std::vector<label_t>();
    node->body = parseBlock(true);
    inFunction = oldInFunc; labels = oldLabels;

    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
    if (LOGICALOR(strict,node->body->bodyarr.size() && isUseStrict(node->body->bodyarr[0]))) {
{
      // Negative indices are used to reuse loop body for node->rest and node->id
      auto i = -2;  Node* id = 0; ; for (; i < node->params.size();)
{
        if (i >= 0) {
{
          id = node->params[i];
        }
} else if (i == -2) {
{
          if (node->rest) {
id = node->rest;
} else continue;
        }
} else {
          if (node->id) {
id = node->id;
} else continue;
        }
        if (LOGICALOR(isStrictReservedWord(id->name),isStrictBadIdWord(id->name))) {
raise(id->start, std::string("Defining '") + id->name + std::string("' in strict mode"));
}
        if (i >= 0) {
auto j = 0; ; for (; j < i;)
if (id->name == node->params[j]->name) {
raise(id->start, "Argument name clash in strict mode");
}
}
      }
    }
}

    return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
  }

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  std::vector<Node*> parseExprList(keyword_t close, bool allowTrailingComma, bool allowEmpty) {
    auto elts = std::vector<Node*>();  auto first = true; 
    while (!eat(close)) {
      if (!first) {
{
        expect(_comma);
        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) {
break;
}
      }
} else first = false;

      if (allowEmpty && tokType == _comma) {
push(elts, null);
} else push(elts, parseExpression(true));
    }
    return elts;
  }

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  Node* parseIdent(bool liberal) {
    auto node = startNode(); 
    if (liberal && options.forbidReserved == "everywhere") {
liberal = false;
}
    if (tokType == _name) {
{
      if (!liberal &&
          (LOGICALOR(options.forbidReserved &&
           (options.ecmaVersion == 3 ? isReservedWord3 : isReservedWord5)(tokVal),strict && isStrictReservedWord(tokVal))) &&
          indexOf(slice(input, tokStart, tokEnd), "\\") == -1) {
raise(tokStart, std::string("The keyword '") + tokVal + std::string("' is reserved"));
}
      node->name = tokVal;
    }
} else if (liberal && tokType.keyword) {
{
      node->name = tokType.keyword;
    }
} else {
      unexpected();
    }
    tokRegexpAllowed = false;
    next();
    return finishNode(node, "Identifier");
  }

